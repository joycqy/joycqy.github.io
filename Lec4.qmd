---
title: "Day4: Regression Analysis and Reporting Results"
author: "Qingyin Cai"
institute: |
  Department of Applied Economics<br>University of Minnesota
format: 
  revealjs:
    self-contained: false
    slide-number: c/t
    width: 1600
    height: 900
    theme: default 
    scss: ../slide_style/styles.scss
    fontsize: 1.8em
    callout-icon: false
    scrollable: true
    echo: true
    cache: true
    warning: false
    multiplex: false
    code-link: true
    title-slide-attributes:
      data-background-color: "#e6e6fa"
    fig-dpi: 400
    chalkboard: true
    preview-links: true
filters:
  - webr
  - fontawesome
webr:
  packages: ["data.table", "ggplot2", "dplyr", "modelsummary", "AER", "wooldridge"]
  cell-options:
    editor-font-scale: 0.8
---

## Recap {.center}
<br>

So far, we have learned...

+ The basic types of data structures in R, and how to create and manipulate them.
+ Data wrangling with `data.table` package.
+ Data visualization with `ggplot2` package.

With the tools we learned so far, you can do a lot of tasks for descriptive data analysis!

Once you have a good understanding of the data, you can move on to the next step: econometric analysis!

## {.center}

### {{< fa bullseye >}} Learning Objectives

Today's goal is to:

+ create a descriptive summary table for the data.
+ use `lm` function to estimate a regression model and report the results with publication-ready summary tables.
+ understand how to create a report document (html and PDF) with Quarto. 

<br>

:::{.fragment .center}
### {{< fa asterisk >}} Reference {.center}
+ `modelsummary` package [See [here](https://modelsummary.com/) for the package documentation, important!]
:::


## Notes {.center}
<br>

+ Today's lecture is an introduction to basic regression analysis with R.

+ The more advanced R functions such as `feols()` function from `fixest` package for fixed effects models and `glm()` function for generalized linear models will be covered in the Econometric class (APEC 8211-8214).
  + But the basic syntax are the same. So, you can easily apply the knowledge you learn today to the more advanced functions.

<br>



## Today's outline: {.center}

1. [Introduction to Regression analysis with R](#introduction-to-regression-analysis-with-r)
2. [Create a summary table](#create-summary-tables)
   - [Introduction to `modelsummary` package](#modelsummary-package-introduction)
   - [`modelsummary()` function to report regression results](#modelsummary-function-introduction)
   - [`modelsummary()` function: Customization](#modelsummary-function-customization)
   - [`datasummary()` function to report descriptive statistics](#datasummary-function-introduction)
   


# Introduction to Regression analysis with R {#introduction-to-regression-analysis-with-r}

---

```{r}
#| autorun: true
#| echo: false

library(wooldridge)
library(data.table)
library(dplyr)
library(modelsummary)
library(ggplot2)
```


```{r}
#| label: setup
#| include: false
#| cache: false
req <- c("modelsummary","AER","wooldridge","data.table","dplyr","ggplot2","sandwich")
miss <- setdiff(req, rownames(installed.packages()))
if (length(miss)) install.packages(miss)
invisible(lapply(req, library, character.only = TRUE))
```


## Before We Start

We will use the `CPS1988` dataset from the `AER` package. It's a cross-section dataset originating from the March 1988 Current Population Survey by the US Census Bureau. For further information, see `?CPS1988` after loading the package.

Run the following code: 
```{webr-r}
#| autorun: true
library(AER)
data(CPS1988)

# I prefer to convert the data to data.table. 
setDT(CPS1988)

# For practice, I converted some factor variables into character variables.
CPS1988[,`:=`(
  ethnicity = as.character(ethnicity),
  region = as.character(region),
  parttime = as.character(parttime)
)]
```



```{r}
#| autorun: true
#| include: false
#| echo: false
library(AER)
data(CPS1988)

# I prefer to conver the data to data.table. 
setDT(CPS1988)

# For practice, I convert the some factor variables into character variables.
CPS1988[,`:=`(
  ethnicity = as.character(ethnicity),
  region = as.character(region),
  parttime = as.character(parttime)
)]
```


## Introduction to Regression Analysis with R

<!-- start: Introduction to lm() function -->
:::{.panel-tabset}
### Basics of lm()

The most basic function to estimate a linear regression model in R is the `lm` function from `stats` package, which is a built-in R package.

<br>

Suppose we have a regression model of the form:
$$Y = \beta_0 + \beta_1 X_1 + \beta_2 X_2 + e$$

<br>

With the `lm` function, we can estimate the above model as follows:
```{r}
#| eval: false
# Example R-code
lm(formula = Y ~ X1 + X2, data = dataset)
```

<br>

+ In the first argument of the `lm` function, you specify the formula of the regression model.
+ The intercept is included by default. So, you don't need to include it in the formula.
+ `~` splits the left side and right side in a formula.  



### Example 

Let's estimate the following model with the `CPS1988` data:

$$wage = \beta_0 + \beta_1 education + \beta_2 experience + e$$

<br>

```{webr-r}
# Your turn. What is the code? What does the output look like? Can you find any other information other than the estimated coefficients?

reg <- # write your code here
```

:::{.notes}
+ The output looks so simple. 
+ But the the output of `lm` function contains a lot of information other than the estimated coefficients.
+ See `names()` (or `ls()`). Or you can see the information stored in the 
:::

### Summary Results

To see the summary of the regression results, use the `summary` function.

```{webr-r}
reg <- lm(formula= wage ~ education + experience, data = CPS1988)
reg_summary <- summary(reg)
```


### Extracting Information1

The results from `lm()` and `summary()` contain a lot of information (In your Rstudio, you can check them on the Environment pane). 

```{webr-r}
# See the objects stored in the results of lm() function. 
ls(reg)
# See the objects stored inside the result of summary() function
ls(reg_summary)
```


[You can access any information stored in  object via the `$` operator.]{style="color: blue"}

::: {.panel-tabset}

### Example 1: Extract the fitted values

```{webr-r}
fitted_values <- reg$fitted.values
```

### Example 2: The coefficient estimates

```{webr-r}
coef_estimates <- reg$coefficients
# or you can use the `coef` function (from the same package for `lm` function)
# coef_estimates <- coef(reg)
```

###  Example 3: The coefficient estimates with standard errors and t-statistics. 

```{webr-r}
tbl_coef_estimates <- reg_summary$coefficients
```

:::


### Extracting Information2   

-  Contents of `lm()` vs `summary(lm())` objects.  
<br>

| Category           | In `lm()` object (`reg`)                     | In `summary(lm())` object (`reg_summary`) |
|-------------------------|--------------------------------------------------|-----------------------------------------------|
| Coefficients        | `coefficients`: estimated β-hats                 | `coefficients`: table of β-hat, Std. Error, t, p |
| Residuals           | `residuals`: raw residuals                       | `residuals`: residuals (trimmed for summary)  |
| Fitted Values       | `fitted.values`: predicted ŷ                     | –                                             |
| Model Info          | `call`, `terms`, `model`, `assign`, `xlevels`    | `call`, `terms`, plus degrees of freedom info |
| Diagnostics         | –                                                | `r.squared`, `adj.r.squared`, `sigma`, `fstatistic` |
| Variance–Covariance | `qr`, `effects`, `rank`, `df.residual`           | `cov.unscaled`, `aliased`                     |
| Degrees of Freedom  | `df.residual`                                    | `df`: regression, residual, total             |



### In-class Exercise

::: {.panel-tabset}

### Questions

Let's get the value of the standard error of the coefficient estimate of `education`.


```{webr-r}
# You can write your code here.

```

### Answers


Let's get the value of the standard error of the coefficient estimate of `education`.


```{webr-r}


```


:::
<!-- end: Introduction to lm() function -->
:::


## Regression with Various Functional Forms
<br>

### Basics

+ To include interaction terms in the formula in `lm()` function:
  + **`*`** = main effects + interactions.  
  + **`:`** = interaction only.

+ To include arithmetic terms in the formula in `lm()` function, use the `I()` function.  
  + **`I()`** = arithmetic (square, product, etc).  

+ For log transformation, use the `log()` function in the formula.  
  + Or you define a new variable with the transformed variable and include it in the formula.


**Example:**

To estimate: 
$$log(wage) = \beta_0 + \beta_1 education + \beta_2 experience + \beta3 experience ^2 + e$$

```{webr-r}
summary(
  lm(log(wage) ~ education + experience + I(experience^2), data = CPS1988)
)

#lm(log(wage) ~ education + experience + I(experience^2), data = CPS1988) %>%
#  summary()
```


## Categorical Variables

<!-- start panel: categorical -->
::: {.panel-tabset}

### Basics

What if we want to include a categorical variable (e.g., `region`, `parttime`, `ethnicity`) in the regression model? 


`lm()` function is smart enough to convert the categorical variable into dummy variables without any additional coding.

+ Even the variables you want to use as dummy variables are character type, `lm()` function automatically coerced it into a factor variable. 



### Examples
<!-- start panel: example -->
:::{.panel-tabset}

### Two categories

What if we want to include a dummy variable that takes 1 if `parttime` is yes, otherwise 0?

The model is as follows:
$$
log(wage) = \beta_0  + \beta_1 education + \beta_2 experience + \beta_3 experience^2 + \beta_4 d_{parttime, yes} + e
$$


```{webr-r}
summary(
  lm(log(wage) ~ education + experience + I(experience^2) + parttime , data = CPS1988)
)

#lm(log(wage) ~ education + experience + I(experience^2) + parttime, data = CPS1988) %>%
#  summary()
```


### More than Two Categories

What if we want to include dummy variables for each `region`?

```{webr-r}
CPS1988[, region := factor(region)]
levels(CPS1988$region)                          

# set the base level
CPS1988[, region := relevel(region, ref = "south")]

# run the model
cps_region <- lm(log(wage) ~ ethnicity + education + experience + I(experience^2) + region,
                 data = CPS1988)
summary(cps_region)
```

<!-- end panel: example -->
:::


### Set the Base Group

By default, R picks the first group in the alphabetical order for the base group.

You can use `relevel()` function (a built-in R function) to set the base group of the categorical variable.

**Syntax:**
```{r}
#| eval: false
relevel(factor_variable, ref = "base_group")
```

<br>

**Example:**

Let's compare the two regression results: 

+ use `parttime==no` as the base group
+ use `parttime==yes` as the base group

```{webr-r}
# 1. Use the group with parttime==no as the base group (default)
CPS1988[, parttime := relevel(as.factor(parttime), ref = "no")]
# check 
unique(CPS1988$parttime)

summary(
  lm(log(wage) ~ ethnicity + education + experience + I(experience^2) + parttime,
     data = CPS1988)
)$coefficients

# 2. Use the group with parttime==Yes as the base group
CPS1988[, parttime := relevel(as.factor(parttime), ref = "yes")]

summary(
  lm(log(wage) ~ ethnicity + education + experience + I(experience^2) + parttime,
     data = CPS1988)
)$coefficients
```

<!-- end panel: categorical -->
:::

## Prediction

To do prediction with the estimated model on a new dataset, you can use the `predict` function (built-in R function).

**Syntax**

```{r}
#| eval: false
predict(lm_object, newdata = new_dataset)
```


**Example**

```{webr-r}
reg <- lm(log(wage) ~ experience + I(experience^2), data = CPS1988)

new_data <- 
  data.table(
    experience = seq(from = 10, to = max(CPS1988$experience), by = 0.5)
  )

new_data[, predicted_wage := predict(reg, newdata = new_data)]

# visualize the predicted values
ggplot(new_data) +
  geom_point(aes(x = experience, y = predicted_wage), color = "blue") +
  theme_bw()
```


## Key Points {.center}
<br>

You should at least know these key points:

+ the basic usage of `lm()` and `summary()` function.
+ how to retrieve the information stored in the outputs of `lm()` and `summary()` functions. 
+ how to include log-transformed variable, interaction terms and quadratic terms in the formula of `lm()` function.
+ how to include categorical variables in the formula of `lm()` function, and how to set the base group.
+ how to do prediction with the estimated model on a new dataset.

That's it!


# Create Publication-Ready Summary Tables {#create-summary-tables}

## Introduction to `modelsummary` package {#modelsummary-package-introduction}

:::{.panel-tabset}
### Intro
[`modelsummary` package](https://modelsummary.com/) lets you create a nice summary table to report the descriptive statistics of the data and the regression results.

We focus on two functions in the `modelsummary` package:

+ `datasummary()`: to create a summary table for the descriptive statistics of the data.
+ `modelsummary()`: to create a summary table for the regression results.


<!-- Features:

+ present your regression results side by side in the same table.
+ easy to replace the standard errors with the robust ones. 
+ easy to customize the appearance of table.
+ the table can be exported to various formats such as HTML, PDF, and Word. -->

Check the [documentation](https://modelsummary.com/) for more details.


### Example

:::{.columns}

:::{.column width="50%"}

### Descriptive Statistics
```{r}
#| label: tbl-ex1-datasummary
#| tbl-cap: "Example of Summary Statistics"
#| echo: false
#| eval: true

copy(CPS1988) %>%
  .[,`:=`(
    Wage = wage,
    Education = education,
    Experience = experience
  )] %>%
datasummary(
  Wage + Education + Experience ~ Mean + SD + Min + Max,
  data = .,
  output = "gt",
  coef_map = c(
    "wage" = "Wage"
    )
  )
```

:::

:::{.column width="50%"}
### Regression Summary Table

```{r}
#| label: tbl-ex2-datasummary
#| tbl-cap: "Example regression results"
#| echo: false
#| eval: true

# change the base group for ethnicity to "cauc"
ex_dt <-
  copy(CPS1988) %>%
  .[,ethnicity := relevel(as.factor(ethnicity), ref = "cauc")]

ls_regs <- 
  list(
    "OLS 1" = lm(log(wage) ~ education, data = ex_dt),
    "OLS 2" = lm(log(wage) ~ education + experience + I(experience^2), data = ex_dt),
    "OLS 3" = lm(log(wage) ~ education + experience + I(experience^2) + ethnicity, data = ex_dt)
  )

modelsummary(
  models = ls_regs,
  coef_map = c(
    "education" = "Education", 
    "experience" = "Experience", 
    "I(experience^2)" = "Experience squared",
    "ethnicityafam" = "White"
    ),
  output = "gt",
  stars  =  c("*" = .05, "**" = .01, "***" = .001), 
  gof_map = c("nobs", "r.squared",  "adj.r.squared"),
  notes = list("Std. Errors in parentheses")
  )
```
:::

:::

:::


## modelsummary() function to report regression results {#modelsummary-function-introduction}
<!-- start panel: `modelsummary()` function -->
:::{.panel-tabset}

### Basics

The very basic argument of the `modelsummary()` function is the `models` argument, which takes **a list of regression models** you want to report in the table.

```r
# --- 1. Estimate regression models --- #
lm1 <- lm(y ~ x1, data = dataset)
lm2 <- lm(y ~ x1 + x2, data = dataset)
lm3 <- lm(y ~ x1 + x2 + x3, data = dataset)

# --- 2. Then, provide those a list of lm objects in the "models" argument  --- #
modelsummary(models=list(lm1, lm2, lm3))
```


### Default Appearance
:::{.columns}
:::{.column width="50%"}
**Example**

```{r}
#| echo: true
#| results: hide
reg1 <- lm(log(wage) ~ education, data = CPS1988)
reg2 <- lm(log(wage) ~ education + experience + I(experience^2), data = CPS1988)

modelsummary(models=list(reg1, reg2))
```
:::

:::{.column width="50%"}

```{r}
#| echo: false
modelsummary(models=list(reg1, reg2), output = "gt")
```
:::
:::
<!-- end panel: `modelsummary()` function -->
:::


## modelsummary() function: Customization {#modelsummary-function-customization}

:::{.panel-tabset}

### List of Options

The default table is okay. But you can customize the appearance of the table. Here, I listed the bare minimum of options you might want to know (There are lots of other options!).

+ `models`: you can change the name of the models
+ `coef_map`: to reorder coefficient rows and change their labels
+ `stars`: to change the significance stars
+ `vcov`: to replace the standard errors with the robust ones (we will see this later)
+ `gof_map`: to define which model statistics to display
+ `gof_omit`: to define which model statistics to omit from the default selection of model statistics
+ `notes`: to add notes at the bottom of the table
+ `fmt`: change the format of numbers

<br>

**Note**  
+ See `?modelsummary` for more details or see [this](https://modelsummary.com/reference/modelsummary.html).
+ Also check the vignette of the function from [here](https://modelsummary.com/vignettes/modelsummary.html).


### models

By naming the models when you make a list of regression models, you can change the name of the models in the table.

**Example**

:::{.columns}
:::{.column width="50%"}
```{r}
#| echo: true
#| eval: false 
#| code-line-numbers: "4"

reg1 <- lm(log(wage) ~ education, data = CPS1988)
reg2 <- lm(log(wage) ~ education + experience + I(experience^2), data = CPS1988)

ls_regs <- list("OLS 1" = reg1, "OLS 2" = reg2)

modelsummary(models = ls_regs)
```
:::
:::{.column width="50%"}
```{r}
#| echo: false
reg1 <- lm(log(wage) ~ education, data = CPS1988)
reg2 <- lm(log(wage) ~ education + experience + I(experience^2), data = CPS1988)

ls_regs <- list("OLS 1" = reg1, "OLS 2" = reg2)

modelsummary(
  models = ls_regs,
  output = "gt"
  )
```
:::
:::

### coef_map

+ `coef_map` argument helps you clean up your regression table.

  + You can choose which coefficients to show (subset).
  + You can change their order (reorder).
  + You can give them nicer labels (rename).
  + If you give a named vector, the names you supply will replace the default variable names in the table.  
<br>

**Example**

In this example, I renamed the variables and moved the `intercept` row to the bottom row.

:::{.columns}
:::{.column width="50%"}
```{r}
#| eval: false
#| code-line-numbers: "8-12"

modelsummary(
  models =  list("OLS 1" = reg1, "OLS 2" = reg2),
  coef_map = c(
    "education" = "Education", 
    "experience" = "Experience", 
    "I(experience^2)" = "Experience squared",
    "(Intercept)" = "Intercept"
    )
  )
```
:::

:::{.column width="50%"}
```{r}
#| echo: false
modelsummary(
  models =  list("OLS 1" = reg1, "OLS 2" = reg2),
  coef_map = c(
    "education" = "Education", 
    "experience" = "Experience", 
    "I(experience^2)" = "Experience squared",
    "(Intercept)" = "Intercept"
    ),
  output = "gt"
  )
```
:::
:::

### stars

`stars = TRUE` shows the significance stars in the table (Try it!). 

If you don't like it, you can modify significance levels and markers by specifying a named numeric vector (e.g., `stars  =  c("*" = .05, "**" = .01, "***" = .001)`).


**Example**

:::{.columns}
:::{.column width="50%"}
```{r}
#| eval: false
#| code-line-numbers: "13"
modelsummary(
  models = list("OLS 1" = reg1, "OLS 2" = reg2),
  coef_map = c(
    "education" = "Education", 
    "experience" = "Experience", 
    "I(experience^2)" = "Experience squared",
    "(Intercept)" = "Intercept"
    ),
  stars  =  c("*" = .05, "**" = .01, "***" = .001), 
  )
```
:::
:::{.column width="50%"}
```{r}
#| echo: false
modelsummary(
  models = list("OLS 1" = reg1, "OLS 2" = reg2),
  coef_map = c(
    "education" = "Education", 
    "experience" = "Experience", 
    "I(experience^2)" = "Experience squared",
    "(Intercept)" = "Intercept"
    ),
  stars  =  c("*" = .05, "**" = .01, "***" = .001), 
  output = "gt"
  )
```
:::
:::

###  vcov
<!-- start panel: vcov -->

:::{.panel-tabset}

### Basics

`vcov` argument let you replace the non-robust standard errors (default) with the robust one. Here are some options to use the `vcov` argument (see [this](https://modelsummary.com/vignettes/modelsummary.html#vcov) more options).

<br>

:::{.columns}
:::{.column width="50%"}
**Option 1**: Supply a list of named variance-covariance matrices:

```r
vcov_reg1 <- vcovHC(reg1, type = "HC1")
vcov_reg2 <- vcovHC(reg2, type = "HC1")

modelsummary(
  models = list("OLS 1" = reg1, "OLS 2" = reg2), 
  vcov = list(vcov_reg1, vcov_reg2)
  )
```
:::

:::{.column width="50%"}
**Option 2**: Supply a name or a list of names of variance-covariance estimators (e.g, "HC0", "HC1", "HC2", "HC3", "HAC").

```r
modelsummary(
  models = list("OLS 1" = reg1, "OLS 2" = reg2), 
  vcov = "HC1"
  )
```
In this case, HC1 estimator is used for all the models. 
:::
:::

<br>

**Note**  

By default, `modelsummary()` calculates the robust variance-covariance matrix using the `sandwich` package (`sandwich::vcovHC`, `sandwich::vcovCL`).

### Preparation

First, let's get the heteroscedasticity robust variance-covariance matrix for the regression models.

```{r}
reg3 <- lm(log(wage) ~ parttime + ethnicity, data = CPS1988)
reg4 <- lm(log(wage) ~ parttime, data = CPS1988)

# Heteroscedasticity Robust standard errors
library(sandwich)
vcov_reg3 <- vcovHC(reg3, type = "HC1")
vcov_reg4 <- vcovHC(reg4, type = "HC1")
```

### Report robust-standard errors
:::{.columns}

:::{.column width="50%"}

**Before**

```{r}
#| eval: false
modelsummary(
  models = list("OLS 1" = reg3, "OLS 2" = reg4),
  stars  =  c("*" = .05, "**" = .01, "***" = .001)
  )
```
```{r}
#| echo: false
modelsummary(
  models = list("OLS 1" = reg3, "OLS 2" = reg4),
  stars  =  c("*" = .05, "**" = .01, "***" = .001), 
  output = "gt"
  )
```
:::


:::{.column width="50%"}
**VCOV swapped**

```{r}
#| eval: false
modelsummary(
  models = list("OLS 1" = reg3, "OLS 2" = reg4),
  stars  =  c("*" = .05, "**" = .01, "***" = .001), 
  vcov = list(vcov_reg3, vcov_reg4)
  )
```
```{r}
#| echo: false
modelsummary(
  models = list("OLS 1" = reg3, "OLS 2" = reg4),
  stars  =  c("*" = .05, "**" = .01, "***" = .001), 
  vcov = list(vcov_reg3, vcov_reg4),
  output = "gt"
  )
```
:::
:::

<!-- end panel: vcov -->
:::

### coef_omit

`coef_omit` lets you omit coefficient rows from the default selections. In the argument, you specify a vector of names or row number of variables you want to omit from the table.

+ e.g., `coef_omit = c(2,3,5)`  omits the second, third, and fifth coefficients.

**Example**

Let's remove the intercept from the table.

:::{.columns}
:::{.column width="50%"}
```{r}
#| eval: false
#| code-line-numbers: "13"
#| cache: false
modelsummary(
  models = list("OLS 1" = reg1, "OLS 2" = reg2),
  coef_map = c(
    "education" = "Education", 
    "experience" = "Experience", 
    "I(experience^2)" = "Experience squared",
    "(Intercept)" = "Intercept"
    ),
  stars  =  c("*" = .05, "**" = .01, "***" = .001),
  coef_omit = 1
  )
```
:::
:::{.column width="50%"}
```{qr}
#| echo: false
#| cache: false
modelsummary(
  models = list("OLS 1" = reg1, "OLS 2" = reg2),
  coef_map = c(
    "education" = "Education", 
    "experience" = "Experience", 
    "I(experience^2)" = "Experience squared",
    "(Intercept)" = "Intercept"
    ),
  stars  =  c("*" = .05, "**" = .01, "***" = .001), 
  coef_omit = "(Intercept)",
  output = "gt"
  )
```
:::
:::


### gof_map and gof_omit

By default, the `modelsummary()` function reports lots of model statistics (e.g., $R^2$, $AIC$, $BIC$). You can select or omit the model statistics by specifying the `gof_map` and `gof_omit` arguments.

+ You can see the list of model statistics in `modelsummary()` by running `modelsummary::gof_map`
<br>

**Example**

For example, let's select only the number of observations, $R^2$, and adjusted $R^2$ using the `gof_map` argument.

:::{.columns}
:::{.column width="50%"}
```{r}
#| eval: false
#| code-line-numbers: "13"
modelsummary(
  models = list("OLS 1" = reg1, "OLS 2" = reg2),
  coef_map = c(
    "education" = "Education", 
    "experience" = "Experience", 
    "I(experience^2)" = "Experience squared"
    ),
  stars  =  c("*" = .05, "**" = .01, "***" = .001),
  gof_map = c("nobs", "r.squared",  "adj.r.squared", "logLik")
  )
```
:::
:::{.column width="50%"}
```{r}
#| echo: false
modelsummary(
  models = list("OLS 1" = reg1, "OLS 2" = reg2),
  coef_map = c(
    "education" = "Education", 
    "experience" = "Experience", 
    "I(experience^2)" = "Experience squared"
    ),
  stars  =  c("*" = .05, "**" = .01, "***" = .001), 
  gof_map = c("nobs", "r.squared",  "adj.r.squared", "logLik"),
  output = "gt"
  )
```
:::
:::

### others

+ `notes` lets you add notes at the bottom of the table.
+ `fmt` lets you change the format of numbers in the table.

**Example**

For example, let's select only the number of observations, $R^2$, and adjusted $R^2$ using the `gof_map` argument.

:::{.columns}
:::{.column width="50%"}
```r
modelsummary(
  models = list("OLS 1" = reg1, "OLS 2" = reg2),
  coef_map = c(
    "education" = "Education", 
    "experience" = "Experience", 
    "I(experience^2)" = "Experience squared"
    ),
  stars  =  c("*" = .05, "**" = .01, "***" = .001),
  gof_map = c("nobs", "r.squared",  "adj.r.squared"),
  notes = list("Std. Errors in parentheses"),
  fmt = 2 #report the numbers with 2 decimal points
  )
```
:::
:::{.column width="50%"}
```{r}
#| echo: false
modelsummary(
  models = list("OLS 1" = reg1, "OLS 2" = reg2),
  coef_map = c(
    "education" = "Education", 
    "experience" = "Experience", 
    "I(experience^2)" = "Experience squared"
    ),
  stars  =  c("*" = .05, "**" = .01, "***" = .001), 
  gof_map = c("nobs", "r.squared",  "adj.r.squared"),
    notes = list("Std. Errors in parentheses"),
  fmt = 2,
  output = "gt"
  )
```
:::
:::

:::


## datasummary() function to report descriptive statistics  {#datasummary-function-introduction}
<br>

`modelsummary` package has another function called `datasummary()`  that can create a summary table for the descriptive statistics of the data.

<br>

**Example**

:::{.columns}
:::{.column width="50%"}
```r
datasummary(
  formula = 
    (`Metropolitan area` = smsa) * ( 
      wage + education + experience
    ) ~ 
    ethnicity * (Mean + SD),
  data = CPS1988
  )
```
:::

:::{.column width="50%"}
```{r}
#| echo: false
datasummary(
  formula = 
    (`Metropolitan area` = smsa)*(
      wage + education + experience
    ) ~ 
    ethnicity * (Mean + SD),
  data = CPS1988,
  output = "gt"
  )
```
:::
:::


## datasummary() function: Introduction

<!-- start panel: datasummary() -->
:::{.panel-tabset}

### Basics

`datasummary()` function creates a summary table for the descriptive statistics of the data.

**Syntax**

```r
datasummary(
  formula = rows ~ columns,
  data = dataset
  )
```

<br>

**Note**  

+ Just like `lm`, `formula` takes a two-side formula devided by `~`.
+ The left-hand (right-hand) side of the formula describes the rows (columns).


Let's see how it works with an example.

### Example

```r
datasummary(
  formula = wage + education + experience ~ Mean + SD,
  data = CPS1988
  )
```

<br>

```{r}
#| echo: false
datasummary(
  formula = wage + education + experience ~ Mean + SD,
  data = CPS1988,
  output = "gt"
  )
```

<br>

**Note**  

+ Use `+` to include more rows and columns.
+ The `modelsummary` package offers multiple summary functions of its own:
  + `Mean`, `SD`, `Median`, `Min`, `Max`, `P0`, `P25`, `P50`, `P75`, `P100`, `Histogram`
+ `NA` values are automatically stripped before the computation proceeds. So you don't need to worry about it.


### All()

In the `formula` argument, you can use `All()` function to create a summary table for all the numeric variables in the dataset.


```r
datasummary(
  formula = All(CPS1988)~ Mean + SD,
  data = CPS1988
  )
```

<br>

```{r}
#| echo: false
datasummary(
  formula = All(CPS1988) ~ Mean + SD,
  data = CPS1988,
  output = "gt"
  )
```


### In-class Exercise

```r
datasummary(
  formula = wage + education + experience ~ mean + SD,
  data = CPS1988
  )
```

<br>

```{r}
#| echo: false
datasummary(
  formula = wage + education + experience ~ mean + SD,
  data = CPS1988,
  output = "gt"
  )
```

<br>

**Play with the datasummary() function:**

+ Exchange the rows and columns in the formula and see how the table looks.

+ Add other statistics or variables to the formula and see how the table looks.


<!-- end panel: datasummary() -->
:::


## datasummary() Function: Further Tuning

<!-- start panel -->
:::{.panel-tabset}

### Nesting with `*` operator

`datasummary` can nest variables and statistics inside categorical variables using the `*` symbol. For example, you can display separate means and SD's for each value of `ethnicity`.


<br>

**Example 1: Nested rows**

```r
datasummary(
  formula =  ethnicity * (wage + education + experience) ~ mean + SD,
  data = CPS1988
  )
```

<br>

```{r}
#| echo: false
datasummary(
  formula = ethnicity * (wage + education + experience) ~ mean + SD,
  data = CPS1988,
  output = "gt"
  )
```

<br>

**Example 2: Nested columns**

```r
datasummary(
  formula = wage + education + experience ~ ethnicity * (mean + SD),
  data = CPS1988
  )
```

<br>

```{r}
#| echo: false
datasummary(
  formula = wage + education + experience ~ ethnicity * (mean + SD),
  data = CPS1988,
  output = "gt"
  )
```



### Multiple Nests

+ You can nest variables and statistics inside multiple categorical variables using the `*` symbol.  

+ The order in which terms enter the formula determines the order in which labels are displayed.  

<br>

**Example**

```r
datasummary(
  formula = wage + education + experience ~ region * ethnicity * (mean + SD),
  data = CPS1988
  )
```

<br>

```{r}
#| echo: false
datasummary(
  formula = wage + education + experience ~ region * ethnicity * (mean + SD),
  data = CPS1988,
  output = "gt"
  )
```



### Renaming the Variables with `=`
<!-- start panel:renaming -->

By default, variable and statistics names are used as the labels in the table. You can rename the default labels with the following syntax: `(label = variable/statistic)`.

<br>

**Example**

Before renaming:

```r
datasummary(
  formula = wage + education ~ ethnicity * (mean + SD),
  data = CPS1988
)
```

```{r}
#| echo: false
datasummary(
  formula = wage + education ~ ethnicity * (mean + SD),
  data = CPS1988,
  output = "gt"
)
```

<br>

After renaming:

```r
datasummary(
  formula = (`Wage (in dollars per week)` = wage) + (`Years of Education` = education) ~ ethnicity * (mean + (`Std.Dev` = SD)),
  data = CPS1988
)
```

```{r}
#| echo: false
datasummary(
  formula = (`Wage (in dollars per week)` = wage) + (`Years of Education` = education) ~ ethnicity * (mean + (`Std.Dev` = SD)),
  data = CPS1988,
  output = "gt"
)
```

::: {.callout-caution}
+ In R, ``` `` ``` is used to define a variable name with spaces or special characters such as the parentheses symbol `()`.
:::


### In-class Exercise

:::{.panel-tabset}

### Data

For this exercise problem, we use `CPSSW3` dataset from the `AER` package. The `CPSSW3` dataset provides trends (from 1992 to 2004) in hourly earnings in the US of working college graduates aged 25–34 (in 2004 USD).


```{r}
library(AER)
data("CPSSW9204")
head(CPSSW9204)
```


### Problem

Let's create the following tables:

<br>

**Table 1**

```{r}
#| echo: false
datasummary(
  formula = 
    year *  (earnings + age) ~ gender * (Mean + SD),
  data = CPSSW9204,
  output = "gt"
  )
```

<br>

**Table 2: Rename some labels in Table 1**

```{r}
#| echo: false
datasummary(
  formula = 
    (Year = year) * ((`Avg. hourly earnings` = earnings) + (Age = age))~ gender * (Mean + (`Std.Dev` = SD)),
  data = CPSSW9204,
  output = "gt"
  )
```

### Answers

**Table 1**

```{webr-r}

```

<br>

**Table 2: Rename some labels in Table 1**

```{webr-r}

```


<!-- end panel -->
:::

:::

# Appendix: Other Functions of the modelsummary Package



## datasummary_skim

:::{.panel-tabset}
### Basics

`datasummary_skim()` with the `type = categorical` option might be helpful to  quickly generate a summary table for categorical variables:

<br>

**Syntax**

```r
datasummary_skim(data = dataset, type = "categorical")
```


### Example
```{r}
#| eval: false
datasummary_skim(data = CPS1988[,.(ethnicity, smsa, region, parttime)], type = "categorical")
```

<br>

```{r}
#| echo: false
datasummary_skim(data = CPS1988[,.(ethnicity, smsa, region, parttime)], type = "categorical", output = "gt")
```
:::


## datasummary_balance

:::{.panel-tabset}

### Basics

`datasummary_balance()` function creates balance tables with summary statistics for different subsets of the data (e.g., control and treatment groups). 

<br>

**Syntax**

```r
datasummary_balance(
  formula = variables to summarize ~ group_variable,
  data = dataset
  )
```


### Example
```{r}
#| eval: false
datasummary_balance(
  formula = wage + education + experience ~ ethnicity,
  data = CPS1988,
  dinm_statistic = "std.error" # or "p.value"
)
```

<br>

```{r}
#| echo: false
datasummary_balance(
  formula = wage + education + experience ~ ethnicity,
  data = CPS1988,
  dinm_statistic = "std.error",
  output = "gt"
)
```

:::


## datasummary_correlation

:::{.panel-tabset}

### Basics

`datasummary_correlation()` function creates a correlation table. It automatically identifies all the numeric variables, and calculates the correlation between each of those variables (You don't need to select the numeric variables manually!).

<br>

**Syntax**

```r
datasummary_correlation(data = dataset)
```


### Example
```{r}
#| eval: false
datasummary_correlation(data = CPS1988)
```

<br>

```{r}
#| echo: false
datasummary_correlation(data = CPS1988, output = "gt")
```
:::


## How to create present results in Quarto? {.center}
<br>

+ After running some regression models, ultimately you want to report the results in a neat table.

+ Usually, we report the regression results in a formatted document like the Rmarkdown or Quarto document (html or PDF).

+ So, let's practice how to create a summary table for your analysis results in the Quarto document!

+ From my GuitHub, "materials" under "Data/Materials for Class Use" download and open the document file "practice_modelsummary_html.qmd". 

+ See details [here](https://quarto.org/docs/guide/) - Documents


# Exercise Problems {.center}

You can find today's after-class exercise problems under "Data/Materials for Class Use" on my GuitHub.


