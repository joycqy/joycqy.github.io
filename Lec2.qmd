---
title: "Day 2: Data wrangling with data.table"
author: "Qingyin Cai"
institute: |
  Department of Applied Economics<br>University of Minnesota
format: 
  revealjs:
    self-contained: false
    slide-number: c/t
    width: 1600
    height: 900
    theme: default 
    scss: ../slide_style/styles.scss
    fontsize: 1.8em
    callout-icon: false
    scrollable: true
    echo: true
    cache: true
    warning: false
    multiplex: false
    code-link: true
    title-slide-attributes:
      data-background-color: "#e6e6fa"
    fig-dpi: 400
    chalkboard: true
    preview-links: true
filters:
  - webr
  - fontawesome
webr:
  packages: ["data.table", "dplyr", "rio", "nycflights13", "AER"]
  cell-options:
    editor-font-scale: 0.8
---

## {.center}

### {{< fa bullseye >}} Learning Objectives

- Use basic data wrangling skills with the `data.table` package  
- Learn how to use the `%>%` operator from the `magrittr` package (Optional)  

<br>

### {{< fa asterisk >}} Reference {.center}
- [Introduction to data.table](https://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.html)  
- [Efficient reshaping using data.table](https://cran.r-project.org/web/packages/data.table/vignettes/datatable-reshape.html)  
- [R for Data Science, Ch18: Pipes](https://r4ds.had.co.nz/pipes.html)


## {{< fa list >}} Today's outline: {.center}
1. [Data manipulation with data.table](#intro-data-table)
   + [What is `data.table`?](#what-is-data-table) 
   + [data.table syntax](#syntax-data-table) 
   + [Subset rows](#subset-rows)
   + [Select columns](#select-columns)
   + [Compute on columns](#compute-on-columns)
   + [Create a new column](#create-a-new-column)
   + [Perform aggregations by group](#perform-aggregations-by-group)
   + [Reshape datasets](#reshape-data)
   + [Merge datasets](#merge-multiple-datasets)

2. [`%>%` operator (optional)](#piping)
3. [After-class Exercise Problems](#exercise-problems)
4. [Appendix](#appendix)


# Introduction to data.table {#intro-data-table}

---

## What is `data.table`? {#what-is-data-table}

:::{.panel-tabset}

### What is it?
- `data.table` is a package in R that provides an enhanced version of `data.frame`.
  - It is designed to be fast and memory efficient.

<br>

- There is another package called `dplyr` that is also popular for data wrangling. But `data.table` is much faster than `dplyr` particularly for large-scale data manipulation tasks.  
  - See [this](https://github.com/Rdatatable/data.table/wiki/Benchmarks-%3A-Grouping) for the speed comparison of dplyr and data.table.  
  - [This website](https://atrebas.github.io/post/2019-03-03-datatable-dplyr/) compares dplyr vs data.table side by side. If you already know `dplyr` syntax, this website would be helpful to understand `data.table` syntax.


```{r}
#| include: false
#| eval: false
library(data.table)
library(dplyr)
```

### Before Starting

1. Let's use `flights` data, which is obtained from `nycflights13`.

```{webr-r}
#| autorun: true
# Load flights data from nycflights13 package.
flights <- nycflights13::flights
# Remove rows with missing values (just for convenience)
flights <- na.omit(flights)
# Check the class of object
class(flights)
```

<br>

2. Converting to `data.table`  

- To use the special features of the `data.table` package, the data must be in the `data.table` class.  
- You can convert a `data.frame` (or tibble) into a `data.table` by using the `setDT()` function.


```{webr-r}
#| autorun: true
# Load data.table package
library(data.table)
setDT(flights) # same as, flights <- as.data.table(flights)
# Now, flights is a data.table object.
class(flights)
```
:::


## data.table syntax {.center #syntax-data-table}

The general form of `data.table` syntax is

```{webr-r}
#| eval: false
# Don't run
DT[i, j, by]
```

- `i`: choose rows (filtering or subsetting)
- `j`: choose or transform columns (summaries, calculations, or selecting variables)
- `by`: group by variables (do the calculation in `j` separately for each group)

<br>

**Simply put,**

[Start with a data.table `DT`. First pick rows using `i`, then work on columns with `j`, and if needed, repeat that operation for each group defined by `by.`]{style="color: red;"}


## {.center}

Using data.table syntax, we will see how to:

- subset rows
- select columns, compute on the selected columns, create a new column
- perform aggregations by group


## 1. Subset Rows {#subset-rows}

:::{.panel-tabset}

### Basics

- `data.table` syntax: `DT[i, j, by]`
- To subset rows, put a condition on a **column** inside `i`.  
  - Example: `DT[colA == "value", ]` selects rows where column `colA` equals `"value"`.
  
**Example**

Subset rows where `carrier` is `"AA"` (American Airlines):

```{webr-r}
flights[carrier == "AA",] # a comma after the condition is not required
```

<br>

- What happens here?  
  - `i`: selects rows where `carrier == "AA"`
  - `j`: no action (all columns)
  - `by`: no action (no grouping)


### In-class Exercise

:::{.panel-tabset} 
### Questions
```{webr-r}
# 1. Subset rows where `carrier` is "AA" and `month` is 1 (January)

# 2. Subset rows where `carrier` is "AA" and `origin` is all the airports except "JFK"

# 3. Subset rows where delay in departure (`dep_delay`) is less than 0 or delay in arrival (`arr_delay`) is less than 0. (Hint: use | for "or" condition)

```

### Answers

```{webr-r}
# 1. Subset rows where `carrier` is "AA" and `month` is 1 (January)


# 2. Subset rows where `carrier` is "AA" and `origin` is all the airports except "JFK"


# 3. Subset rows where delay in departure (`dep_delay`) is less than 0 or delay in arrival (`arr_delay`) is less than 0. (Hint: use | for "or" condition)

```

:::

:::


## Other row-related tasks {.center}
<br>
[The key idea: all tasks related to **rows** are done inside `i`.]{style="color: red;"} 

<br>

**Example**

:::{.panel-tabset} 
### Filter rows 

Select flights where `carrier` is `"AA"`:  
  
```{webr-r}
flights[carrier == "AA"]
```  

### Select by row number 

Return the first 5 rows:
  
```{webr-r}
flights[1:5]
```  
  
### Remove rows

Exclude rows 1 to 10:
  
```{webr-r}
flights[-(1:10)]
```  
  
### Sort rows

Sort by `month` (ascending) and then `day` (descending):
  
```{webr-r}
flights[order(month, -day)]

```   
:::


## 2. Select Columns {#select-columns}

:::{.panel-tabset}

### Basics

- `data.table` syntax: `DT[i, j, by]`
- To select columns, use the  `j` argument

**Example**: 

Suppose we want to select `dep_time` column. Since we are not subsetting rows, we leave the `i` argument blank.

```{webr-r}
# --- Select dep_time column as vector --- #
flights[, dep_time]

# --- Select dep_time column as data.table --- #
flights[, list(dep_time)]  # or flights[, .(dep_time)], 

```

- If we wrap variables (column names) in `list()`, the result will be returned as a `data.table`.  
- `.()` is simply shorthand for `list()` in `data.table` syntax.  
- **Important**: In `data.table`, each column is internally stored as a list. When you use `.()` (or `list()`) in the `j` expression, each element of that list becomes a column in the resulting `data.table`.  

<br>

### Multiple columns

You can select multiple columns just like you did to select a single column.

```{webr-r}
# --- Select dep_time and arr_time as data.table --- #
flights[, .(dep_time, arr_time)]

# --- Unselect columns using - or ! --- #
flights[, !c("dep_time", "arr_time")]
# or
# flights[, -c("dep_time", "arr_time")]
```

### In-class exercise

:::{.panel-tabset} 
### Questions
```{webr-r}
# 1. Select year, month, day, and carrier columns as data.table.

```

### Answers
```{webr-r}
# 1. Select year, month, day, and carrier columns as data.table.

```
:::

:::


## 3. Compute on Columns {#compute-on-columns}

<br>

### Basics
- `data.table` syntax: `DT[i, j, by]`
- `j` not only allows you to select columns but also to compute on columns


**Example**

Let's count the number of trips which have had total delay < 0 (i.e., total day = `dep_delay` + `arr_delay`). 

```{webr-r}
# count the number of trips with total delay < 0
flights[, sum((arr_delay + dep_delay) < 0)]  #Let's explore what's going on here. 
```

**What happens in this code?**

- `i`: no action (all rows are used)  
- `j`: takes the sum of the logical vector `arr_delay + dep_delay < 0`  
- `by`: no action (no grouping)  

**Note:** Since we skip the `i` expression, we must include a comma before the `j` expression.


## 3. Compute on Columns of the Subsetted Rows

:::{.panel-tabset}

### Basics

- `data.table` syntax: `DT[i, j, by]`
- Using `i` and `j` expressions together, you can perform calculations on the selected columns of the subsetted rows.

<br>

**Example** 

How many flights departed from “JFK” airport in the month of June?

```{webr-r}
flights[origin == "JFK" & month == 6L, .N]
# NOTE: `.N` is a special variable that holds the number of rows in the current group.
```

<br>

**What happens in this code?**

- `i` : to select rows where origin airport equals “JFK”, and month equals 6.
- `j` : to count the number of rows in the subsetted data.
- `by` : no action (no grouping)


### Multiple outputs

- You can assign names to the values you calculate in `j`.
- Recall that `.()` is a shorthand for `list()` in data.table syntax. You can name each element inside `.()` just like naming elements in a regular list.

<br>

**Example**

Count how many flights departed from JFK airport in June. For those flights, calculate the average departure delay (dep_delay).

```{webr-r}
flights[origin == "JFK" & month == 6L, .(Count = .N, avg_dep_delay = mean(dep_delay))]
```


### In-class exercise

:::{.panel-tabset}

### Questions
1. Find the average arrival delay and the average departure delay for flights that departed from JFK in August.

- Hint: 
  - Use the columns: `origin`, `month`, `arr_delay`, `dep_delay` 
  - Use the `mean()` function to calculate averages


```{webr-r}
# You can write your code here
```

### Answers

1. Find the average arrival delay and the average departure delay for flights that departed from JFK in August.
```{webr-r}

```
:::

:::

## 4. Create a New Column {#create-a-new-column}

:::{.panel-tabset}

### Basics

- `data.table` syntax: `DT[i, j, by]`
- In `j` expression, you can **add** or **update** a column in the data table using the `:=` operator.
  - Think of `:=` as a special assignment operator inside `data.table`. It modifies the data table **by reference** (changes the original table without making a copy).

<br>

**Syntax**

```r
# === Add one column === #
DT[, "new_column_name" := .(valueA)]

# or you can drop the quotes and `.()` for convenience
DT[, new_column_name := valueA]
```

### Example

Using the dataset below, create a new column `c` that is the sum of columns `a` and `b`.

```{webr-r}
# === Simple dataset === #
simple_data <- data.table(a = 1:5, b = 6:10)

# === Create a new column === #
simple_data[, "c" := .(a + b)]

# or simply, you can do 
simple_data[, c := a + b]
```

<br>

**Important Rule**

The operator `:=` creates new columns by updating the data **in place** (by reference). This means the original data table is directly modified.


### Multiple new columns

Here is how you define multiple variables at the same time.

```{webr-r}
#| autorun: false

# === Newly add two columns (formal syntax)  === #
simple_data[, c("c", "d") := .(a + b, a - b)]

# Simplified version
simple_data[, `:=`(
  c = a + b,
  d = a - b
)]
```


### Note

- The `:=` operator in `data.table` does not allow you to reference newly created or modified columns within the same `[` expression.  

- If you want to use a new column in another calculation, you need a second `[` step.


**Example**

- Let's create two new columns: (1) `c` by adding `a` and `b`, and (2) `d` by dividing `c` by `a`.

```{webr-r}
#| eval: false

# This code does not work
flights[, `:=`(
  c = a + b,
  d = c/a,
]

# Instead do this 
flights[, c := a + b]
flights[, d := c/a]
```


### Update with a condition

- Using `i` and `j` expressions together, you can change the column values for rows that satisfy certain conditions.


**Example:** 

```{webr-r}
#| autorun: true

# === Create a simple data === #
simple_data <- data.table(a = 1:5, b = 6:10)

# === Update column b by adding 10 only for the rows with a >= 3  === #
simple_data[a >= 3, b := b + 10]
```

<br>

**Keeping the original data:** 

- If you want to keep the original dataset unchanged, use the `data.table::copy()` function to create a duplicate.

- The object created with `copy()` is completely independent: changes to one will not affect the other.


### In-class exercise

:::{.panel-tabset}

### Questions

Create two new columns in the `flights` data: 

- `total_delay`: the sum of `dep_delay` and `arr_delay`.
- `speed`: the ratio of `distance` to `air_time` (i.e,  `distance/air_time`.)

```{webr-r}
# You can write your code here

```

### Answers

```{webr-r}
#| autorun: true

# === Detailed version === #


# === Simplified version === #

```
:::

:::

## 5. Perform Aggregations by Group (Grouped Operations) {#perform-aggregations-by-group}


:::{.panel-tabset}

### Basics  

- `data.table` syntax: `DT[i, j, by]`
- To perform grouped operations, use `by` argument.

**Syntax**
```{r}
#| eval: false
DT[, .(new_column = function(column)), by = .(group_variable)]
```

<br>

**Example**: Let's find the number of flights by `origin`.
```{webr-r}
flights[, .(.N), by = .(origin)]
```

<br>

**What happens in this code?**

- `i`: no action (all rows) 
- `j`: count the number of rows in each group defined by `by` argument
- `by`: group the data by `origin`


###  Group by multiple columns

Nothing special. Just provide multiple columns to `by` argument.

<br>

**Example**: Find the average time of departure delay and arrival delay by `carrier` and `origin`.
```{webr-r}
flights[, .(avg_dep_delay = mean(dep_delay), avg_arr_delay = mean(arr_delay)), by = .(carrier, origin)]
```


### Grouped operations for select observations

By combining the `i` argument with by, you can perform grouped operations on a subset of rows.

<br>

**Example 1**: Get the number of flights for each origin airport for carrier code "AA" (American Airlines).
```{webr-r}
flights[carrier == "AA", .N, by = .(origin)]
```

**What happens in this code?**
- `i`: subset rows where `carrier` is "AA"
- `j`: count the number of rows in each group defined by `by` argument
- `by`: group the data by `origin`

<br>

**Example 2**: Find the number of flights by `origin` and `month` for carrier code "AA" (American Airlines).
```{webr-r}
head(flights[carrier == "AA", .N, by = .(origin, month)])
```


### In-class exercise

:::{.panel-tabset}

### Questions

1. For each `month` and each `carrier`, calculate the total number of flights, average departure delay, and average arrival delay.

```{webr-r}
# You can write your code here

```

<br>

2. (Optional) Define seasons (Winter: Dec-Feb, Spring: Mar-May, Summer: Jun-Aug, Fall: Sep-Nov) and summarize the total number of flights, average departure delay, and average arrival delay for each season and each carrier.


```{webr-r}
# You can write your code here

```


### Answers

1. For each month and each carrier, calculate the total number of flights, average departure delay, and average arrival delay.

```{webr-r}

```

<br>

2. (Optional) Define seasons (Winter: Dec-Feb, Spring: Mar-May, Summer: Jun-Aug, Fall: Sep-Nov) and summarize the total number of flights, average departure delay, and average arrival delay for each season and each carrier.

Note: I used `fcase()` function of `data.table` package to define seasons. It is useful when you want to define a variable that takes different values based on conditions.


```{webr-r}
# --- Define season --- #
flights[,season := fcase(
  month %in% c(12, 1, 2), "Winter",
  month %in% c(3, 4, 5), "Spring",
  month %in% c(6, 7, 8), "Summer",
  default = "Fall" #otherwise, "Fall`"
)]

# --- Summarize by season and carrier --- #
flights[, .(
  total_flights = .N,
  avg_dep_delay = mean(dep_delay, na.rm = TRUE),
  avg_arr_delay = mean(arr_delay, na.rm = TRUE)
), by = .(season, carrier)]
```

:::
:::


## Summary {.center}  

So far, we have covered the **basic operations** in the `data.table` package.  

Focus on these key ideas:  

- The general syntax is `DT[i, j, by]`:  
  - `i` → rows  
  - `j` → columns  
  - `by` → groups  

- Use `i` for anything related to **rows**.  
  - Example: filter rows with conditions.  

- Use `j` for anything related to **columns**.  
  - Example: select columns, compute new values (use `.()`), or add/update columns with `:=`.  

- Use `by` for anything related to **grouped operations**.  
  - Example: calculate summaries by group.  

<br>

[With just these three pieces (`i`, `j`, and `by`), you can handle most data manipulation tasks in `data.table`.]{style="color: red;"}



## {.center}

Next, we will see a few advanced topics: 

+ Reshaping Data
+ Merging Multiple Datasets 
+ (and the `%>%` operator if we have time).


## 6. Reshape Data {#reshape-data}

:::{.panel-tabset}

### Basics

Data often comes in two formats: **long** or **wide**.

**Example:**

::: {.columns}

::: {.column width="50%"}
**Long data**: 

Each student appears in multiple rows (one per year).  

```{r}
#| echo: false

library(data.table)

student_long <- data.table(
  student = rep(c("Alice", "Bob", "Charlie", "Diana"), each = 2),
  year = rep(c(2021, 2022), times = 4),
  math = c(78, 85, 92, 95, 88, 90, 70, 80),
  reading = c(82, 88, 90, 93, 85, 87, 75, 83)
)

student_long
```

:::

::: {.column width="50%"}
**Wide data**

Each student appears in one row, with columns for each year’s scores.  


```{r}
#| echo: false
student_wide <- data.table(
  student = c("Alice", "Bob", "Charlie", "Diana"),
  math_2021 = c(78, 92, 88, 70),
  math_2022 = c(85, 95, 90, 80),
  reading_2021 = c(82, 90, 85, 75),
  reading_2022 = c(88, 93, 87, 83)
)

student_wide
```
:::

:::

<br>

- We can convert one format to another using `dcast()` and `melt()` functions of `data.table` package.


### Long to wide

- Use `dcast()` function converts long form to wide form

**Basic Syntax:**
```{r}
#| eval: false
dcast(data, LHS ~ RHS , value.var = c("var1", "var2"))
```
- `LHS`: set of id variables (variables (columns) that you don’t want change).
- `RHS`: set of variables to be used as the column index.
- `value.var`: set of variables whose values will be filled to cast.

<br>

**Example:**

Suppose that we want to organize the data so that each student’s math and reading scores appear in the same row.

```{webr-r}
#| autorun: true
student_wide <- dcast(student_long, student ~ year, value.var = c("math", "reading"))
student_wide
```

<br>

**Tips**
- Before coding a reshape, first visualize the format you want the data to take.
- I often sketch a small example table.
  - This helps me to understand what variables I need to use as `LHS`, `RHS`, and `value.var`.


### Wide to long

- Use `melt()` function to convert wide form to long form

**Basic Syntax**:
```{r}
#| eval: false
melt(data, id.var = c("id_var1", "id_var2"), measure.vars = c("var1", "var2"))
```

- `id.vars`: the set of id variables (variables (columns) that you don’t want change).
- `measure.vars`: the set of columns you want to collapse (or combine) together.
- `value.name`: (optional) the name of the new column that will store the values of the variables in `measure.vars`, the default is `value`

<br>

**Example:**

Let's get back to the original data format `student_long` from `student_wide`.

```{webr-r}
# Collect math and reading scores for each year into long format
col_math <- paste0("math_", 2021:2022)
col_read <- paste0("reading_", 2021:2022)

student_long2 <- melt(
  student_wide,
  id.vars = "student",
  measure.vars = list(col_math, col_read),
  value.name = c("math","reading")
)

student_long2

# If you are familiar with regular expressions, you can do:
# melt(student_wide, id.vars = "student", measure.vars = patterns("^math", "^reading"), value.name = c("math", "reading"))
```

- Notice that the year info is stored as variable (1, 2).

```{webr-r}
student_long2[, year := ifelse(variable == 1, 2021, 2022)][, variable := NULL]
student_long2
```


### Why reshape data?

**Summarizing is easier in long form.**

- Example: average math/reading score by year.
  
```{webr-r}
# --- using long-form --- #
student_long[, .(
  avg_math = mean(math),
  avg_reading = mean(reading)
), by = year]

# --- using wide-form --- #
student_wide[, `:=`(
  avg_math = (math_2021 + math_2022) / 2,
  avg_reading = (reading_2021 + reading_2022) / 2
)]

student_wide[, .(student, avg_math, avg_reading)]
```

<br>

**Visualization is easier in long form.**

- Example: plotting scores by year (when we use `ggplot` later).


### In-class exercise

:::{.panel-tabset}

### Questions

Using the following long-form data named `long_data`, can you get back `student_long`?

```{webr-r}
# === create long_dt (run this code) === #
student_wide <- dcast(student_long, student ~ year, value.var = c("math", "reading"))
long_data <- melt(student_wide, id.var = "student")

```

<br>

```{webr-r}
# You can write your code here
# Hint: you can use `tstrsplit()` function to split the variable column by "_"
```


### Answers

```{webr-r}
# First, create two columns: `subject` (math or reading) and `year` by splitting the `variable` column of long_data.


# Drop the old variable column


# Finally, cast the data back to the original long form

```

:::

:::

## 7. Merge Multiple Datasets {#merge-multiple-datasets}

:::{.panel-tabset}

### Basics

You can use the `merge()` function from the `data.table` package to merge two datasets.
<br><br>

**Basic Syntax**:
```{r}
#| eval: false
# Merge data y to data x keeping all rows from data x
merge(x, y, by = "key_column", all.x = TRUE)
```

- `x`, `y`: data tables.
- `by`: specifies variables that let you merge two datasets.
- `all.x = TRUE` means that all rows from `x` are maintained in the merged dataset, and only matching rows from `y` are included.  
<br>

Note: [The order of the datasets matter]{style="color: red;"}.


### Example

:::{.panel-tabset}

### Instructions

Let's play around with the `merge()` function using the following small data.

::: {.columns}

::: {.column width="50%"}

**Data 1**
```{webr-r}
#| autorun: true
# --- Math scores --- #
math_data <- 
  data.table(
    student = c("Alice", "Bob", "Carol", "David", "Eva"),
    math = runif(n = 5, min = 60, max = 100)
  )
math_data
```
:::

::: {.column width="50%"}
**Data2**
```{webr-r}
#| autorun: true
# --- Reading scores --- #
reading_data <- 
  data.table(
    student = c("Bob", "Carol", "Alice", "Frank", "Grace"),
    reading = runif(5, min = 60, max = 100)
  )
reading_data
```
:::
:::

- Note that the students included in` math_data` and `reading_data` are slightly different. This is to show how the `merge()` function works when there are unmatched rows in the two datasets.  
- To merge these two datasets, `student` works because it is the key column.
<br>


### Merge

**(1) Merge `reading_data` to `math_data`, keeping all rows from `math_data`.**

```{webr-r}
math_reading_data <- merge(math_data, reading_data, by = "student", all.x = TRUE)
# check the merged data
math_reading_data
```

<br>

**(2) Merge `math_data` to `reading_data`, keeping all rows from `reading_data`.**
```{webr-r}
reading_math_data <- merge(reading_data, math_data, by = "student", all.x = TRUE)
# check the merged data
reading_math_data
```

<br>

**(3) If you want to keep all rows from both datasets, set `all = TRUE`.**

```{webr-r}
all_students_data <- merge(math_data, reading_data, by = "student", all = TRUE)
# check the merged data
all_students_data
```

:::

### In-class exercise1

:::{.panel-tabset}

### Questions

(1) In the `flights` data, the `carrier` column contains two-letter codes for airlines. Let's translate these codes into the full name of the airline. 

Airline data from `nycflights13` package contains the full name of the airline corresponding to the two-letter code. The following code loads the airline data.

```{webr-r}
#| autorun: true
airlines <- nycflights13::airlines
head(airlines)
```

<br>

Merge `flights` and `airlines` data, keeping all rows from the `flights` data. Which variable should be used as a key column?

```{webr-r}
# You can write your code here
```

### Answers

- Obviously, `flights` data is the main data, so we should keep all rows from the `flights` data.

- The key column should be `carrier` because it is the common variable in both datasets, and it gives one-to-one correspondence between the two datasets.

```{webr-r}

```
:::

### In-class exercise 2

:::{.panel-tabset}

### Questions

Run the following code to create two datasets: `yield_data` and `weather_data`.
```{webr-r}
#| autorun: true
math_data <- 
  data.table(
    student = rep(c("Alice", "Bob", "Carol", "David", "Eva"), each = 2),
    year = rep(2021:2022, times = 5),
    math = runif(n = 10, min = 60, max = 100)
  )

reading_data <- 
  data.table(
    student = rep(c("Alice", "Bob", "Carol", "Frank", "Grace"), each = 4),
    year = rep(2021:2024, times = 5),
    reading = runif(20, min = 60, max = 100)
  )
```

<br>

Merge these two datasets, keeping all rows from `math_data`. Which variable(s) should be used as key columns?

```{webr-r}
# you can write your code here
```

### Answers

- Here you should use both `student` and `year` as key columns.

```{webr-r}

```

:::
:::


# `%>%` operator {#piping}

---

## Motivation

- In R, you need to assign the result of each operation to a new object if you want to use the result in the subsequent process.
- But sometimes, some objects are just intermediate results that you don't need to keep.


**Example** 

Let's first create `flights_mini` data from `flights` data of `nycflights13` package in the `data.table` format.

```{webr-r}
flights <- nycflights13::flights # Load flights data from nycflights13
flights_dt <- as.data.table(flights) # change the data to data.table class 
flights_mini <- flights_dt[,.(year, month, origin, dest, carrier, air_time, dep_delay, arr_delay)] # select some columns
flights_mini <- na.omit(flights_mini) # remove rows with missing values
```

The first three lines yield intermediate results to make the final `flight_mini`, and you don't need to keep those.

<br>

You can create `flights_mini` without using those intermediate steps with the chaining operation in `data.table` package, but it's hard to read!

```{webr-r}
flights_mini <- na.omit(data.table(nycflights13::flights)[,.(year, month, origin, dest, carrier, air_time, dep_delay, arr_delay)])
```


## Introduction

:::{.panel-tabset}

### What is `%>%`?

- `%>%` a special symbol in R, called a pipe operator. It comes from the `magrittr` package.
- It's a powerful tool to write linear sequence of operations in a more readable way.

<br>

Note: When you load the `dplyr` package, `magrittr` package is automatically loaded as well. So, you don't need to load the `magrittr` package separately to use `%>%`.



### Basics

`%>%` takes the output of the code on its left and feeds it as the first argument to the function on its right.

<br>

**Example 1**

```r
fun1(input1) 
```

is the same as 

```r
input1 %>% fun1()
```
<br>

**Example 2**

```r
output1 <- fun1(input1)
output2 <- fun2(output1)
```

is the same as 

```r
output2 <- fun1(input1) %>% fun2()
```

### Refer to the Preceding Object

What if you want to use the object defined before `%>%` as the second or third argument of the subsequent function?

You can refer the preceding object by `.` in the subsequent function. 

**Example**

```{webr-r}
# Let's use this function
print_three_words <- function(x, y, z) paste(c(x, y, z),collapse = " ")
# For example, this function prints three words with spaces between them
print_three_words(x="I", y="love", z="R")

# pass the input to the first argument
"I" %>% print_three_words(x=., y="love", z="R")

# pass the input to the second argument
"love" %>% print_three_words(x="I", y=., z="R")

# pass the input to the third argument
"R" %>% print_three_words(x="I", y="love", z=.)
```

**Tip**
- Whenever you use `%>%`, I recommend you always use `.` in the subsequent function to **explicitly denote the destination of the object** defined before `%>%` even if it is the first argument.

:::


## Example

**Without `%>%`**
```{webr-r}
#| auto-run: true
flights <- nycflights13::flights 
flights_dt <- as.data.table(flights)
flights_mini <- flights_dt[,.(year, month, origin, dest, carrier, air_time, dep_delay, arr_delay)] 
flights_mini <- na.omit(flights_mini) 
```

**With `%>%`**
```{webr-r}
#| auto-run: true
library(dplyr)

flights_mini <- 
  nycflights13::flights %>%
  as.data.table(.) %>% 
  .[,.(year, month, origin, dest, carrier, air_time, dep_delay, arr_delay)] %>% 
  na.omit(.)
```

<br>

Note that the order of execution is the same as the order in which the functions are written.



## Summary {.center}
<br>
The topics in the second part of this lecture were more advanced, so you don’t need to memorize every function right away.<br><br>

What I want you to remember are the following key ideas:

1. You can reshape data using the functions `dcast()` and `melt()`. Depending on your goal, one format (wide or long) may be easier to analyze than the other.

2. You can merge datasets using the `merge()` function, but you must have at least one common key column between the datasets.

You don't need to use `%>%` operator, unless you thinks it would be more convenient. 



# After-class Exercise Problems {#exercise-problems}

---


## Exercise 1

:::{.panel-tabset}
### Instructions

1. Find the flight company with the longest departure delay. (Hint: use `max()` function to find the maximum value of `dep_delay` column)

2. Subset the information of flights that headed to MSP (Minneapolis-St Paul International Airport) in February. Let's name it "msp_feb_flights". How many flights are there?
  

3. Calculate the median, interquartile range ($IQR = Q3 − Q1$) for `arr_delays` of flights in in the `msp_feb_flights` dataset and the number of flights, grouped by `carrier`. Which carrier has the most variable arrival delays?  
- Hints: IQR = Q3 − Q1 (the difference between the 75th percentile and the 25th percentile.) Use `quantile()` function to calculate the quantiles.

<!-- https://rpubs.com/Nasif/929745 --> 


### Answers

```{webr-r}
#| autorun: false
# === Part 1 === #
flights[dep_delay == max(dep_delay), .(carrier)]

# === Part 2 === #
msp_feb_flights <- flights[dest=="MSP" & month==2L]
nrow(msp_feb_flights)

# === Part 3 === #
msp_feb_flights[,.(
  median = median(arr_delay),
  IQR = quantile(arr_delay, 0.75) - quantile(arr_delay, 0.25),
  n_flights = .N
  ), by = carrier]
```
:::

## Exercise 2

:::{.panel-tabset}

### Instructions

If you were selecting an airport simply based on on-time departure percentage, which NYC airport would you choose to fly out of? 
- To address this question, first, define a new variable which indicates on-time departure. On-time-departure can be defined as a departure delay of less than or equal to 0. Then, calculate the on-time departure rate for each airport.

<br>

```{webr-r}
# You can write your code here
```

### Answers

```{webr-r}
#| autorun: false
flights <- data.table(nycflights13::flights)

flights[, .(on_time_rate = mean(dep_delay <= 0, na.rm = TRUE)), by = origin]

flights[, on_time := dep_delay <= 0] %>%
  .[, .(on_time_rate = mean(on_time, na.rm = TRUE)), by = origin]
```
:::


## Exercise 3

:::{.panel-tabset}
### Data

For this exercise problem, we will use `journal` data from the `AER` package.   
- First, load the data and convert it to data.table object using `setDT` function (or. `as.data.table()`). Take a look at the data.  
- Also, type `?journal` to see the description of the data.

<br>

```{webr-r}
#| autorun: false
# If you have not installed the package, run the following code
# install.packages("AER")

# load the package
library(AER)
# load the data from AER
data("Journals")

# To see the descriptions of the data, 
# type `?Journals` in the console
?Journals

setDT(Journals)
```

### Instructions

1. Calculate the average number of pages and price for the entire dataset.  

2. Show the `title`, `citations`, `price`, and `subs` columns for the top 5 journals (`title`) with the highest number of citations (`citations`). (Hint: use `order()` function to sort the data by `citations` in descending order.). 

3. This dataset is created in the year 2000. Calculate the age (`age`) of each journal by subtracting the start year (`foundingyear`) of the journal from 2000. Select the columns, `price`, `subs`, `citations`, and `pages`, and `age`. Use that data to create a correlation matrix between those variables using the `cor()` function. (Hint: use this syntax: `cor(data)`). Can you find anything interesting from the correlation matrix?

```{webr-r}
# You can write your code here
```

### Solutions

```{webr-r}
#| autorun: false
# === Part 1 === #
Journals[, .(
  avg_pages = mean(pages, na.rm = TRUE),
  avg_price = mean(price, na.rm = TRUE)
)]

# === Part 2 === #
Journals[order(-citations), .(title, citations, price, subs)][1:5]

# === Part 3 === #
Journals[, age := 2000 - foundingyear]
cor(Journals[, .(price, subs, citations, pages, age)])
```
:::


# Appendix {#appendix}

<!-- ## Appendix: Table of Contents

+ A.1. A list of useful functions
+ [A.2. Let's get used to .SD](#SD)
+ A.3. Exercise Problems 
+ A.4. Use multiple cores for computation with data.table [[Here](https://github.com/Rdatatable/data.table/wiki/Installation)] -->


## Useful functions

+ `.N`
+ `copy()`
+ `setnames()`
+ `order()`
+ `shift()`
+ `duplicated()`: find duplicates
+ `unique()`: find unique observations
+ `fcase()`


## fcase()

+ `fcase()` function is useful when you want to define a variable that takes different values based on conditions.

+ `fcase()` function returns the first value for which the corresponding condition is `TRUE`. If no condition is `TRUE`, it returns the default value.

```{webr-r}
x = 1:10
fcase(
	x <= 5L, 1L,
	x > 5L, 3L
)
```

<br>

**Example:** Define seasons (Winter: Dec-Feb, Spring: Mar-May, Summer: Jun-Aug, Fall: Sep-Nov)

```{webr-r}
# --- Define season --- #
flights[,season := fcase(
  month %in% c(12, 1, 2), "Winter",
  month %in% c(3, 4, 5), "Spring",
  month %in% c(6, 7, 8), "Summer",
  default = "Fall" #otherwise, "Fall`"
)]
flights
```




